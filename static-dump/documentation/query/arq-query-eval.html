<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<!--

    Licensed to the Apache Software Foundation (ASF) under one or more
    contributor license agreements.  See the NOTICE file distributed with
    this work for additional information regarding copyright ownership.
    The ASF licenses this file to You under the Apache License, Version 2.0
    (the "License"); you may not use this file except in compliance with
    the License.  You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE- 2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
-->

  <link href="/css/jena.css" rel="stylesheet" type="text/css">

  <title>Apache Jena - ARQ - Extending Query Execution</title>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js" type="text/javascript"></script>
  <script src="/js/jena-navigation.js" type="text/javascript"></script>
</head>

<body>
  <div id="header">
    <div id="logoblock">
    <img alt="Apache Jena" src="/images/jena-logo/jena-logo-small.png"/>
    </div>

    <div id="titleblock">
      <h1 class="title">Apache Jena</h1>
      <div id="topmenu" class="tabbar round-10">
        <ul>
        <li class="round-top-8"><a class="round-top-8" href="/index.html" id="home_menu">Home</a></li>
        <li class="round-top-8"><a class="round-top-8" href="/help_and_support/index.html">Support</a></li>
        <li class="round-top-8"><a class="round-top-8" href="/getting_started/index.html">Getting started</a></li>
        <li class="round-top-8"><a class="round-top-8" href="/tutorials/index.html">Tutorials</a></li>
        <li class="round-top-8"><a class="round-top-8" href="/documentation/index.html">Documentation</a></li>
        </ul>
      </div>
    </div>
  </div>

  <div id="navigation" class="clear">
  <h1 id="quick-links">Quick links</h1>
<ul>
<li><a href="/index.html">Home</a></li>
<li><a href="/download/index.html">Downloads</a></li>
<li><a href="/help_and_support/index.html">Help and support</a></li>
<li><a href="/help_and_support/bugs_and_suggestions.html">Report a bug</a></li>
<li><a href="/about_jena/roadmap.html">Roadmap</a></li>
<li><a href="/getting_involved/index.html">Getting involved</a></li>
<li><a href="/documentation/">Documentation</a></li>
</ul>
<h1 id="about-jena">About Jena</h1>
<ul>
<li><a href="/index.html">Home</a></li>
<li><a href="/about_jena/about.html">About Jena</a></li>
<li><a href="/about_jena/architecture.html">Architecture</a></li>
<li><a href="/about_jena/roadmap.html">Roadmap</a></li>
<li><a href="/about_jena/team.html">Project team</a></li>
<li><a href="/about_jena/contributions.html">Related projects</a></li>
</ul>
<h1 id="download">Download</h1>
<ul>
<li><a href="/download/index.html">Downloading Jena</a></li>
<li><a href="/download/maven.html">Using Maven</a></li>
<li><a href="/download/osgi.html">Using OSGi</a></li>
</ul>
<h1 id="help-and-support">Help and support</h1>
<ul>
<li><a href="/help_and_support/index.html">Getting help</a></li>
<li><a href="/help_and_support/bugs_and_suggestions.html">Bugs and suggestions</a></li>
</ul>
<h1 id="getting-started">Getting Started</h1>
<ul>
<li><a href="/getting_started/index.html">A first Jena project</a></li>
<li><a href="/getting_started/rdf_api.html">RDF API overview</a></li>
<li><a href="/getting_started/sparql.html">Querying RDF with SPARQL</a></li>
<li><a href="/getting_started/fuseki.html">Serving RDF over HTTP</a></li>
<li><a href="/getting_started/tell_me_how.html">Tell me how to ...</a></li>
</ul>
<h1 id="tutorials">Tutorials</h1>
<ul>
<li><a href="/tutorials/index.html">Tutorials index</a></li>
<li><a href="/tutorials/rdf_api.html">RDF tutorial</a></li>
<li><a href="/tutorials/sparql.html">SPARQL queries</a></li>
<li><a href="/tutorials/using_jena_with_eclipse.html">Using Jena with Eclipse</a></li>
</ul>
<h1 id="documentation">Documentation</h1>
<ul>
<li><a href="/documentation/index.html">Overview</a></li>
<li><a href="/documentation/javadoc/">Javadoc</a></li>
<li><a href="/documentation/rdf/index.html">RDF</a></li>
<li><a href="/documentation/io/index.html">I/O</a></li>
<li><a href="/documentation/query/index.html">SPARQL (ARQ)</a><ul>
<li><a href="/documentation/query/app_api.html">Application API</a></li>
<li><a href="/documentation/query/cmds.html">Command line utilities</a></li>
</ul>
</li>
<li><a href="/documentation/query/text-query.html">Text Search</a></li>
<li><a href="/documentation/tdb/index.html">TDB</a><ul>
<li><a href="/documentation/tdb/tdb_transactions.html">API for Transactions</a></li>
<li><a href="/documentation/tdb/assembler.html">Dataset Assembler</a></li>
</ul>
</li>
<li><a href="/documentation/serving_data/index.html">Fuseki: Serving Data</a></li>
<li><a href="/documentation/ontology/index.html">Ontology</a></li>
<li><a href="/documentation/inference/index.html">Inference</a></li>
<li><a href="/documentation/assembler/index.html">Assembler</a><ul>
<li><a href="/documentation/assembler/assembler-howto.html">Assembler how-to</a></li>
<li><a href="/documentation/assembler/inside-assemblers.html">Inside assemblers</a></li>
</ul>
</li>
<li><a href="/documentation/sdb/index.html">SDB</a></li>
<li><a href="/documentation/notes/index.html">Notes</a><ul>
<li><a href="/documentation/notes/concurrency-howto.html">Concurrency how-to</a></li>
<li><a href="/documentation/notes/event-handler-howto.html">Event handler how-to</a></li>
<li><a href="/documentation/notes/file-manager.html">File manager how-to</a></li>
<li><a href="/documentation/notes/model-factory.html">Model factory how-to</a></li>
<li><a href="/documentation/notes/rdf-frames.html">RDF frames</a></li>
<li><a href="/documentation/notes/reification.html">Reification how-to</a></li>
<li><a href="/documentation/notes/typed-literals.html">Typed literals how-to</a></li>
<li><a href="/documentation/notes/iri.html">Support for IRI's</a></li>
<li><a href="/documentation/notes/sse.html">SSE</a></li>
</ul>
</li>
<li><a href="/documentation/tools/index.html">Tools</a><ul>
<li><a href="/documentation/tools/schemagen.html">schemagen</a></li>
<li><a href="/documentation/tools/eyeball-getting-started.html">eyeball</a></li>
</ul>
</li>
</ul>
<h1 id="getting-involved">Getting Involved</h1>
<ul>
<li><a href="/getting_involved/index.html">Contributing to Jena</a><ul>
<li><a href="/getting_involved/reviewing_contributions.html">Reviewing Contributions</a></li>
</ul>
</li>
</ul>
<h1 id="asf-links">ASF links</h1>
<ul>
<li><a href="http://www.apache.org">Apache Software Foundation</a></li>
<li><a href="http://www.apache.org/licenses/LICENSE-2.0">License</a></li>
<li><a href="http://www.apache.org/foundation/thanks.html">Thanks</a></li>
<li><a href="http://www.apache.org/foundation/sponsorship.html">Become a Sponsor</a></li>
<li><a href="http://www.apache.org/security/">Security</a></li>
</ul>
  </div>

  <div id="content">
    <h1 class="title">ARQ - Extending Query Execution</h1>
    <p>This page describes the mechanisms that can be used to extend and
modify query execution within ARQ. Through these mechanisms, ARQ
can be used to query different graph implementations and to provide
different query evaluation and opti-mization strategies for
particular circumstances. These mechanisms are used by
<a href="../tdb">TDB-</a> and <a href="../sdb/">SDB</a>.-</p>
<p>ARQ can be <a href="extension.html">extended in various ways</a> to
incorporate custom code into a query.
<a href="extension.html#value-functions">Custom filter functions</a> and
<a href="extension.html#property-functio-ns">property functions</a> p-rovi-de ways
to add application specific code. The
<a href="/documentation/larq/">free text search</a> capabilities, using Apache
Lucene, are provided via a property function. Custom filter
functions and property functions should be used where possible.</p>
<p>Jena itself can be extended by providing a new implementation of
the <code>Graph</code> interface. This can be used to encapsulate specific
specialised storage and also for wrapping non-RDF sources to look
like RDF. There is a common implementation framewo-fk provided-fby
<code>GraphBase</code> so only one operation, the <code>find</code> method, needs to be
written for a read-only data source. Basic find works well is many
cases, and the whole Jena API will be able to use the extension. 
For higher SPARQL performance, ARQ can be extended at the
<a href="#stage-generator">basic graph matching</a> or
<a href="#opexecutor">algebra level</a>.</p>
<p>Applications writers who extend ARQ at the query execution level
should be prepared to work with the source code for ARQ for
specific details and for finding code to reuse. Some example can be
found in the <code>src-examples</code> directory in the ARQ download.</p>
<ul>
<li><a href="#overview">Overview of ARQ Query processing-</a></li>
<li><a href="#main-query-engine">The Main Query Engine</a></li>
<li><a href="#stage-generator">Graph matching and a custom StageGenerator</a></li>
<li><a href="#opexecutor">OpExecutor</a></li>
<li><a href="#quads">Quads</a></li>
<li><a href="#mixed-datasets">Mixed Graph Implementation Datasets</a></li>
<li><a href="#custom-query-engines">Custom Query Engines</a></li>
<li><a href="#algebra-extensions">Extend the algebra</a></li>
</ul>
<h2 id="overview-of-arq-query-processing">Overview of ARQ Query Processing</h2>
<p>The sequence of actions performed by ARQ to perform a query are
parsing, algebra generation, execution building, high-level
optimization, low-level optimization and finally evaluation. It is
not usual to modify the parsing step nor the conversion from the
parse tree to the algebra form, which is a fixed algorithm defined
by the SPARQL standard. Extensions can modify the algebra form by
transforming it from one algebra expression to another, including
introducing new operators. See also the documentation on
<a href="algebra.html">working with the SPARQL algebra in ARQ</a> including
building algebra expressions programmatically, rather than
obtaining them from a query string.</p>
<h3 id="parsing">Parsing</h3>
<p>The parsing step turns a query string into a <code>Query</code> object. The
class <code>Query</code> represents the abstract syntax tree (AST) for the
query and provides methods to create the AST, primarily for use by
the parser. The query object also provides methods to serialize the
query to a string. Because this is the AST, the string produced is
very close to the original query with the same syntactic elements,
but without comments, and formatted with a whitespace for
readability. It is not usually the best way to build a query
programmatically and the AST is not normally an extension point.</p>
<p>The query object can be used many times. It is not modified once
created, and in particular it is not modified by query execution.</p>
<h3 id="algebra-generation">Algebra generation</h3>
<p>ARQ generates the
<a href="http://www.w3.org/TR/sparql11-query/#sparqlQuery">SPARQL algebra</a>
expression for the query. After this a number of transformations
can be applied (for example, identification of property functions)
but the first step is the application of the algorithm in the
SPARQL specification for translating a SPARQL query string, as held
in a <code>Query</code> object into a SPARQL algebra expression. This includes
the process of removing joins involving the identity pattern (the
empty graph pattern).</p>
<p>For example, the query:</p>
<div class="codehilite"><pre><span class="n">PREFIX</span> <span class="n">foaf</span><span class="o">:</span> <span class="o">&lt;</span><span class="n">http</span><span class="o">:</span><span class="c1">//xmlns.com/foaf/0.1/&gt;</span>
<span class="n">SELECT</span> <span class="o">?</span><span class="n">name</span> <span class="o">?</span><span class="n">mbox</span> <span class="o">?</span><span class="n">nick</span>
<span class="n">WHERE</span>  <span class="p">{</span> <span class="o">?</span><span class="n">x</span> <span class="n">foaf</span><span class="o">:</span><span class="n">name</span>  <span class="o">?</span><span class="n">name</span> <span class="p">;</span>
            <span class="nl">foaf:</span><span class="n">mbox</span>  <span class="o">?</span><span class="n">mbox</span> <span class="p">.</span>
         <span class="n">OPTIONAL</span> <span class="p">{</span> <span class="o">?</span><span class="n">x</span>  <span class="n">foaf</span><span class="o">:</span><span class="n">nick</span>  <span class="o">?</span><span class="n">nick</span> <span class="p">}</span>
       <span class="p">}</span>
</pre></div>


<p>becomes</p>
<div class="codehilite"><pre><span class="p">(</span><span class="n">prefix</span> <span class="p">((</span><span class="n">foaf</span><span class="o">:</span> <span class="o">&lt;</span><span class="n">http</span><span class="o">:</span><span class="c1">//xmlns.com/foaf/0.1/&gt;))</span>
  <span class="p">(</span><span class="n">project</span> <span class="p">(</span><span class="o">?</span><span class="n">name</span> <span class="o">?</span><span class="n">mbox</span> <span class="o">?</span><span class="n">nick</span><span class="p">)</span>
    <span class="p">(</span><span class="n">leftjoin</span>
      <span class="p">(</span><span class="n">bgp</span>
        <span class="p">(</span><span class="n">triple</span> <span class="o">?</span><span class="n">x</span> <span class="n">foaf</span><span class="o">:</span><span class="n">name</span> <span class="o">?</span><span class="n">name</span><span class="p">)</span>
        <span class="p">(</span><span class="n">triple</span> <span class="o">?</span><span class="n">x</span> <span class="n">foaf</span><span class="o">:</span><span class="n">mbox</span> <span class="o">?</span><span class="n">mbox</span><span class="p">)</span>
      <span class="p">)</span>
      <span class="p">(</span><span class="n">bgp</span> <span class="p">(</span><span class="n">triple</span> <span class="o">?</span><span class="n">x</span> <span class="n">foaf</span><span class="o">:</span><span class="n">nick</span> <span class="o">?</span><span class="n">nick</span><span class="p">)</span>
      <span class="p">)</span>
    <span class="p">)))</span>
</pre></div>


<p>using the <a href="../notes/sse.html">SSE syntax</a> to write out
the internal data-structure for the algebra.</p>
<p>The <a href="http://www.sparql.org/validator.html">online SPARQL validator</a>
at <a href="http://sparql.org/">sparql.org</a> can be used to see the algebra
expression for a SPARQL query. This validator is also include in
<a href="../serving_data/">Fuseki</a>.</p>
<h3 id="high-level-optimization-and-transformations">High-Level Optimization and Transformations</h3>
<p>There is a collection of transformations that can be applied to the
algebra, such as replacing equality filters with a more efficient
graph pattern and an assignment. When extending ARQ, a query
processor for a custom storage layout can choose which
optimizations are appropriate and can also provide its own algebra
transformations.</p>
<p>A transform is code that converts an algebra operation into other
algebra operations. It is applied using the <code>Transformer</code> class:</p>
<div class="codehilite"><pre><span class="n">Op</span> <span class="n">op</span> <span class="o">=</span> <span class="p">...</span> <span class="p">;</span>
<span class="n">Transform</span> <span class="n">someTransform</span> <span class="o">=</span> <span class="p">...</span> <span class="p">;</span>
<span class="n">op</span> <span class="o">=</span> <span class="n">Transformer</span><span class="p">.</span><span class="n">transform</span><span class="p">(</span><span class="n">someTransform</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span> <span class="p">;</span>
</pre></div>


<p>The <code>Transformer</code> class applies the transform to each operation in
the algebra expression tree. <code>Transform</code> itself is an interface,
with one method signature for each operation type, returning a
replacement for the operator instance it is called on.</p>
<p>One such transformation is to turn a SPARQL algebra expression
involving named graphs and triples into one using quads. This
transformation is performed by a call to <code>Algebra.toQuadForm</code>.</p>
<p>Transformations proceed from the bottom of the expression tree to
the top. Algebra expressions are best treated as immutable so a
change made in one part of the tree should result in a copy of the
tree above it.  This is automated by the  <code>TransformCopy</code> class
which is the commonly used base class for writing transforms. The
other helper base class is <code>TransformBase,</code> which provides the
identify operation (returns the node supplied) for each transform
operation.</p>
<p>Operations can be printed out in
<a href="../notes/sse.html">SSE</a> syntax. The Java <code>toString</code>
method is overridden to provide pretty printing and the static
methods in <code>WriterOp</code> provide output to various output objects like
<code>java.io.OutputStream</code>.</p>
<h3 id="low-level-optimization-and-evaluation">Low-Level Optimization and Evaluation</h3>
<p>The step of evaluating a query is the process of executing the
algebra expression, as modified by any transformations applied, to
yield a stream of pattern solutions. Low-level optimizations
include choosing the order in which to evaluate basic graph
patterns. These are the responsibility of the custom storage layer.
Low-level optimization can be carried out dynamically as part of
evaluation.</p>
<p>Internally, ARQ uses iterators extensively. Where possible,
evaluation of an operation is achieved by feeding the stream of
results from the previous stage into the evaluation. A common
pattern is to take each intermediate result one at a time (use
<code>QueryIterRepeatApply</code> to be called for each binding) ,
substituting the variables of pattern with those in the incoming
binding, and evaluating to a query iterator of all results for this
incoming row. The result can be the empty iterator (one that always
returns false for <code>hasNext</code>). It is also common to not have to
touch the incoming stream at all but merely to pass it to
sub-operations.</p>
<h3 id="query-engines-and-query-engine-factories">Query Engines and Query Engine Factories</h3>
<p>The steps from algebra generation to query evaluation are carried
out when a query is executed via the <code>QueryExecution.execSelect</code> or
other <code>QueryExecution</code> exec operation. It is possible to carry out
storage-specific operations when the query execution is created. A
query engine works in conjunction with a <code>QueryExecution</code> created
by the <code>QueryExecutionFactory</code> to provide the evaluation of a query
pattern. <code>QueryExecutionBase</code> provides all the machinery for the
different result types and does not need to be modified by
extensions to query execution.</p>
<p>ARQ provides three query engine factories; the main query engine
factory, one for a reference query engine and one to remotely
execute a query. SDB and TDB provide their own query engine
factories which they register during sub-system initialization.
Both extend the main query engine described below.</p>
<p>The reference query engine is a direct top-down evaluation of the
expression. It's purpose is to be simple so it can be easily
verified and checked then its results used to check more
complicated processing in the main engine and other
implementations. All arguments to each operator are fully evaluated
to produce intermediate in-memory tables then a simple
implementation of the operator is called to calculate the results.
It does not scale and does not perform any optimizations. It is
intended to be clear and simple; it is not designed to be
efficient.</p>
<p>Query engines are chosen by referring to the registry of query
engine factories.</p>
<div class="codehilite"><pre><span class="n">public</span> <span class="n">interface</span> <span class="n">QueryEngineFactory</span>
<span class="p">{</span>
    <span class="n">public</span> <span class="n">boolean</span> <span class="n">accept</span><span class="p">(</span><span class="n">Query</span> <span class="n">query</span><span class="p">,</span> <span class="n">DatasetGraph</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">Context</span> <span class="n">context</span><span class="p">)</span> <span class="p">;</span>
    <span class="n">public</span> <span class="n">Plan</span> <span class="nf">create</span><span class="p">(</span><span class="n">Query</span> <span class="n">query</span><span class="p">,</span> <span class="n">DatasetGraph</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">Binding</span> <span class="n">inputBinding</span><span class="p">,</span> <span class="n">Context</span> <span class="n">context</span><span class="p">)</span> <span class="p">;</span>

    <span class="n">public</span> <span class="n">boolean</span> <span class="nf">accept</span><span class="p">(</span><span class="n">Op</span> <span class="n">op</span><span class="p">,</span> <span class="n">DatasetGraph</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">Context</span> <span class="n">context</span><span class="p">)</span> <span class="p">;</span>
    <span class="n">public</span> <span class="n">Plan</span> <span class="nf">create</span><span class="p">(</span><span class="n">Op</span> <span class="n">op</span><span class="p">,</span> <span class="n">DatasetGraph</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">Binding</span> <span class="n">inputBinding</span><span class="p">,</span> <span class="n">Context</span> <span class="n">context</span><span class="p">)</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>When the query execution factory is given a dataset and query, the
query execution factory tries each registered engine factory in
turn calling the <code>accept</code> method (for query of algebra depending on
how it was presented). The registry is kept in reverse registration
order - the most recently registered query engine factory is tried
first. The first query engine factor to return true is chosen and
no further engine factories are checked.</p>
<p>When a query engine factory is chosen, the <code>create</code> method is
called to return a <code>Plan</code> object for the execution. The main
operation of the plan interface is to get the <code>QueryIterator</code> for
the query.</p>
<p>See the example in
<code>src-examples/arq.examples.engine.MyQueryEngine</code>.</p>
<h2 id="the-main-query-engine">The Main Query Engine</h2>
<p>The main query engine can execute any query. It contains a number
of basic graph pattern matching implementations including one that
uses the <code>Graph.find</code> operation so it can work with any
implementation of the Jena Graph SPI. The main query engine works
with general purpose datasets but not quad stores directly; it
evaluates patterns on each graph in turn. The main query engine
includes optimizations for the standard Jena implementation of
in-memory graphs.</p>
<p>High-level optimization is performed by a sequence of
transformations. This set of optimizations is evolving. A custom
implementation of a query engine can reuse some or all of these
transformations (see <code>Algebra.optimize</code> which is the set of
transforms used by the main query engine).</p>
<p>The main query engine is a streaming engine. It evaluates
expressions as the client consumes each query solution. After
preparing the execution by creating the initial conditions (a
partial solution of one row and no bound variables or any initial
bindings of variables), the main query engine calls <code>QC.execute</code>
which is the algorithm to execute a query. Any extension that
wished to reuse some of the main query engine by providing it's own
<code>OpExecutor</code> must call this method to evaluate a sub-operation.</p>
<p><code>QC.execute</code> finds the currently active <code>OpExecutor</code> factory,
creates an <code>OpExecutor</code> object and invokes it to evaluate one
algebra operation.</p>
<p>There are two points of extension for the main query engine:</p>
<ul>
<li>Stage generators, for evaluating basic graph patterns and
    reusing the rest of the engine.</li>
<li><code>OpExecutor</code> to execute any algebra operator specially.</li>
</ul>
<p>The standard <code>OpExecutor</code> invokes the stage generator mechanism to
match a basic graph pattern.</p>
<h2 id="graph-matching-and-a-custom-stagegenerator">Graph matching and a custom StageGenerator</h2>
<p>The correct point to hook into ARQ for just extending basic graph
pattern matching (BGPs) is to provide a custom <code>StageGenerator</code>. 
(To hook into filtered basic graph patterns, the extension will
need to provide it's own <code>OpExecutor</code> factory). The advantage of
the <code>StageGenerator</code> mechanism, as compared to the more general
<code>OpExecutor</code> described below, is that it more self-contained and
requires less detail about the internal evaluation of the other
SPARQL algebra operators.  This extension point corresponds to
section 12.6
"<a href="http://www.w3.org/TR/sparql11-query/#sparqlBGPExtend">Extending SPARQL Basic Graph Matching</a>".</p>
<p>Below is the default code to match a BGP from
<code>OpExecutor.execute(OpBGP, QueryIterator)</code>. It merely calls fixed
code in the <code>StageBuilder</code> class.The input is a stream of results
from earlier stages. The execution must return a query iterator
that is all the possible ways to match the basic graph pattern for
each of the inputs in turn. Order of results does not matter. </p>
<div class="codehilite"><pre><span class="n">protected</span> <span class="n">QueryIterator</span> <span class="nf">execute</span><span class="p">(</span><span class="n">OpBGP</span> <span class="n">opBGP</span><span class="p">,</span> <span class="n">QueryIterator</span> <span class="n">input</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">BasicPattern</span> <span class="n">pattern</span> <span class="o">=</span> <span class="n">opBGP</span><span class="p">.</span><span class="n">getPattern</span><span class="p">()</span> <span class="p">;</span>
    <span class="k">return</span> <span class="n">StageBuilder</span><span class="p">.</span><span class="n">execute</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">input</span><span class="p">,</span> <span class="n">execCxt</span><span class="p">)</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>The <code>StageBuilder</code> looks for the stage generator by accessing the
context for the execution:</p>
<div class="codehilite"><pre><span class="n">StageGenerator</span> <span class="n">stageGenerator</span> <span class="o">=</span> <span class="p">(</span><span class="n">StageGenerator</span><span class="p">)</span><span class="n">context</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">ARQ</span><span class="p">.</span><span class="n">stageGenerator</span><span class="p">)</span> <span class="p">;</span>
</pre></div>


<p>where the context is the global context and any query execution
specific additions together with various execution control
elements.</p>
<p>A <code>StageGenerator</code> is an implementation of:</p>
<div class="codehilite"><pre>    <span class="n">public</span> <span class="n">interface</span> <span class="n">StageGenerator</span>
    <span class="p">{</span>
        <span class="n">public</span> <span class="n">QueryIterator</span> <span class="n">execute</span><span class="p">(</span><span class="n">BasicPattern</span> <span class="n">pattern</span><span class="p">,</span>
                                     <span class="n">QueryIterator</span> <span class="n">input</span><span class="p">,</span>
                                     <span class="n">ExecutionContext</span> <span class="n">execCxt</span><span class="p">)</span> <span class="p">;</span>
    <span class="p">}</span>
</pre></div>


<h3 id="setting-the-stage-generator">Setting the Stage Generator</h3>
<p>An extension stage generator can be registered on a per-query
execution basis or (more usually) in the global context.</p>
<div class="codehilite"><pre>    <span class="n">StageBuilder</span><span class="p">.</span><span class="n">setGenerator</span><span class="p">(</span><span class="n">Context</span><span class="p">,</span> <span class="n">StageGenerator</span><span class="p">)</span>
</pre></div>


<p>The global context can be obtained by a call to <code>ARQ.getContext()</code></p>
<div class="codehilite"><pre>    <span class="n">StageBuilder</span><span class="p">.</span><span class="n">setGenerator</span><span class="p">(</span><span class="n">ARQ</span><span class="p">.</span><span class="n">getContext</span><span class="p">(),</span> <span class="n">myStageGenerator</span><span class="p">)</span> <span class="p">;</span>
</pre></div>


<p>In order to allow an extensions to still permit other graphs to be
used, stage generators are usually chained, with each new custom
one passing the execution request up the chain if the request is
not supported by this custom stage generator.</p>
<div class="codehilite"><pre><span class="n">public</span> <span class="n">class</span> <span class="n">MyStageGenerator</span> <span class="n">implements</span> <span class="n">StageGenerator</span>
<span class="p">{</span>
    <span class="n">StageGenerator</span> <span class="n">above</span> <span class="o">=</span> <span class="n">null</span> <span class="p">;</span>

    <span class="n">public</span> <span class="nf">MyStageGenerator</span> <span class="p">(</span><span class="n">StageGenerator</span> <span class="n">original</span><span class="p">)</span>
    <span class="p">{</span> <span class="n">above</span> <span class="o">=</span> <span class="n">original</span> <span class="p">;</span> <span class="p">}</span>

    <span class="err">@</span><span class="n">Override</span>
    <span class="n">public</span> <span class="n">QueryIterator</span> <span class="n">execute</span><span class="p">(</span><span class="n">BasicPattern</span> <span class="n">pattern</span><span class="p">,</span> <span class="n">QueryIterator</span> <span class="n">input</span><span class="p">,</span> <span class="n">ExecutionContext</span> <span class="n">execCxt</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Graph</span> <span class="n">g</span> <span class="o">=</span> <span class="n">execCxt</span><span class="p">.</span><span class="n">getActiveGraph</span><span class="p">()</span> <span class="p">;</span>
        <span class="c1">// Test to see if this is a graph we support.</span>
        <span class="k">if</span> <span class="p">(</span> <span class="o">!</span> <span class="p">(</span> <span class="n">g</span> <span class="n">instanceof</span> <span class="n">MySpecialGraphClass</span> <span class="p">)</span> <span class="p">)</span>
            <span class="c1">// Not us - bounce up the StageGenerator chain</span>
            <span class="k">return</span> <span class="n">above</span><span class="p">.</span><span class="n">execute</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">input</span><span class="p">,</span> <span class="n">execCxt</span><span class="p">)</span> <span class="p">;</span>
        <span class="n">MySpecialGraphClass</span> <span class="n">graph</span> <span class="o">=</span> <span class="p">(</span><span class="n">MySpecialGraphClass</span> <span class="p">)</span><span class="n">g</span> <span class="p">;</span>
        <span class="c1">// Create a QueryIterator for this request</span>
     <span class="p">...</span>
</pre></div>


<p>This is registered by setting the global context (<code>StageBuilder</code>
has a convenience operation to do this):</p>
<div class="codehilite"><pre>  <span class="c1">// Get the standard one.</span>
  <span class="n">StageGenerator</span> <span class="n">orig</span> <span class="o">=</span> <span class="p">(</span><span class="n">StageGenerator</span><span class="p">)</span><span class="n">ARQ</span><span class="p">.</span><span class="n">getContext</span><span class="p">().</span><span class="n">get</span><span class="p">(</span><span class="n">ARQ</span><span class="p">.</span><span class="n">stageGenerator</span><span class="p">)</span> <span class="p">;</span>
  <span class="c1">// Create a new one</span>
  <span class="n">StageGenerator</span> <span class="n">myStageGenerator</span><span class="o">=</span> <span class="n">new</span> <span class="n">MyStageGenerator</span><span class="p">(</span><span class="n">orig</span><span class="p">)</span> <span class="p">;</span>
  <span class="c1">// Register it</span>
  <span class="n">StageBuilder</span><span class="p">.</span><span class="n">setGenerator</span><span class="p">(</span><span class="n">ARQ</span><span class="p">.</span><span class="n">getContext</span><span class="p">(),</span> <span class="n">myStageGenerator</span><span class="p">)</span> <span class="p">;</span>
</pre></div>


<p>Example: <code>src-examples/arq.examples.bgpmatching</code>.</p>
<h2 id="opexecutor">OpExecutor</h2>
<p>A <code>StageGenerator</code> provides matching for a basic graph pattern. If
an extension wishes to take responsibility for more of the
evaluation then it needs to work with <code>OpExecutor</code>. This includes
evaluation of filtered basic graph patterns.</p>
<p>An example query using a filter:</p>
<div class="codehilite"><pre><span class="n">PREFIX</span>  <span class="n">dc</span><span class="o">:</span>   <span class="o">&lt;</span><span class="n">http</span><span class="o">:</span><span class="c1">//purl.org/dc/elements/1.1/&gt;</span>
<span class="n">PREFIX</span>  <span class="n">books</span><span class="o">:</span> <span class="o">&lt;</span><span class="n">http</span><span class="o">:</span><span class="c1">//example.org/book/&gt;</span>

<span class="n">SELECT</span>  <span class="o">*</span>
<span class="n">WHERE</span>
  <span class="p">{</span> <span class="o">?</span><span class="n">book</span>  <span class="n">dc</span><span class="o">:</span><span class="n">title</span>  <span class="o">?</span><span class="n">title</span> <span class="p">.</span>
    <span class="n">FILTER</span> <span class="n">regex</span><span class="p">(</span><span class="o">?</span><span class="n">title</span><span class="p">,</span> <span class="s">&quot;Paddington&quot;</span><span class="p">)</span>
  <span class="p">}</span>
</pre></div>


<p>results in the algebra expression for the pattern:</p>
<div class="codehilite"><pre>    <span class="p">(</span><span class="n">filter</span> <span class="p">(</span><span class="n">regex</span> <span class="o">?</span><span class="n">title</span> <span class="s">&quot;Paddington&quot;</span><span class="p">)</span>
        <span class="p">(</span><span class="n">bgp</span> <span class="p">(</span><span class="n">triple</span> <span class="o">?</span><span class="n">book</span> <span class="n">dc</span><span class="o">:</span><span class="n">title</span> <span class="o">?</span><span class="n">title</span><span class="p">)</span>
        <span class="p">))</span>
</pre></div>


<p>showing that the filter is being applied to the results of a basic
graph pattern matching.</p>
<p>Note: this is not the way to provide custom filter operations.  See
the documentation for
<a href="extension.html#valueFunctions">application-provided filter functions</a>.</p>
<p>Each step of evaluation in the main query engine is performed by a
<code>OpExecutor</code> and a new one is created from a factory at each step. 
The factory is registered in the execution context. The
implementation of a specialized <code>OpExecutor</code> can inherit from the
standard one and override only those algebra operators it wishes to
deal with, including inspecting the execution and choosing to
passing up to the super-class based on the details of the
operation.  From the query above, only regex filters might be
specially handled.</p>
<p>Registering an <code>OpExecutorFactory</code>:</p>
<div class="codehilite"><pre><span class="n">OpExecutorFactory</span> <span class="n">customExecutorFactory</span> <span class="o">=</span> <span class="n">new</span> <span class="n">MyOpExecutorFactory</span><span class="p">(...)</span> <span class="p">;</span>
<span class="n">QC</span><span class="p">.</span><span class="n">setFactory</span><span class="p">(</span><span class="n">ARQ</span><span class="p">.</span><span class="n">getCOntext</span><span class="p">(),</span> <span class="n">customExecutorFactory</span><span class="p">)</span> <span class="p">;</span>
</pre></div>


<p>QC is a point of indirection that chooses the execution process at
each stage in a query so if the custom execution wishes to evaluate
an algebra operation within another operation, it shoudl call
<code>QC.execute</code>. Be careful not to loop endlessly if the operation is
itself handled by the custom evaluator. This can be done by
swapping in a different <code>OpExecutorFactory</code>.</p>
<div class="codehilite"><pre>   <span class="c1">// Execute an operation with a different OpExecution Factory</span>

   <span class="c1">// New context.</span>
   <span class="n">ExecutionContext</span> <span class="n">ec2</span> <span class="o">=</span> <span class="n">new</span> <span class="n">ExecutionContext</span><span class="p">(</span><span class="n">execCxt</span><span class="p">)</span> <span class="p">;</span>
   <span class="n">ec2</span><span class="p">.</span><span class="n">setExecutor</span><span class="p">(</span><span class="n">plainFactory</span><span class="p">)</span> <span class="p">;</span>

   <span class="n">QueryIterator</span> <span class="n">qIter</span> <span class="o">=</span> <span class="n">QC</span><span class="p">.</span><span class="n">execute</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">input</span><span class="p">,</span> <span class="n">ec2</span><span class="p">)</span> <span class="p">;</span>

   <span class="n">private</span> <span class="k">static</span> <span class="n">OpExecutorFactory</span> <span class="n">plainFactory</span> <span class="o">=</span>
      <span class="n">new</span> <span class="n">OpExecutorFactory</span><span class="p">()</span>
      <span class="p">{</span>
         <span class="err">@</span><span class="n">Override</span>
         <span class="n">public</span> <span class="n">OpExecutor</span> <span class="n">create</span><span class="p">(</span><span class="n">ExecutionContext</span> <span class="n">execCxt</span><span class="p">)</span>
         <span class="p">{</span>
             <span class="c1">// The default OpExecutor of ARQ.</span>
             <span class="k">return</span> <span class="n">new</span> <span class="n">OpExecutor</span><span class="p">(</span><span class="n">execCxt</span><span class="p">)</span> <span class="p">;</span>
         <span class="p">}</span>
      <span class="p">}</span> <span class="p">;</span>
</pre></div>


<h2 id="quads">Quads</h2>
<p>If a custom extension provides named graphs, then it may be useful
to execute the quad form of the query. This is done by writing a
custom query engine and overriding <code>QueryEngineMain.modifyOp</code>:</p>
<div class="codehilite"><pre>  <span class="err">@</span><span class="n">Override</span>
  <span class="n">protected</span> <span class="n">Op</span> <span class="n">modifyOp</span><span class="p">(</span><span class="n">Op</span> <span class="n">op</span><span class="p">)</span>
  <span class="p">{</span>
     <span class="c1">// Cope with initial bindings.</span>
     <span class="n">op</span> <span class="o">=</span> <span class="n">Substitute</span><span class="p">.</span><span class="n">substitute</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">initialInput</span><span class="p">)</span> <span class="p">;</span>
     <span class="c1">// Use standard optimizations.</span>
     <span class="n">op</span> <span class="o">=</span> <span class="n">super</span><span class="p">.</span><span class="n">modifyOp</span><span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="p">;</span>
     <span class="c1">// Turn into quad form.</span>
     <span class="n">op</span> <span class="o">=</span> <span class="n">Algebra</span><span class="p">.</span><span class="n">toQuadForm</span><span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="p">;</span>
     <span class="k">return</span> <span class="n">op</span> <span class="p">;</span>
  <span class="p">}</span>
</pre></div>


<p>The extension may need to provide its own dataset implementation so
that it can detect when queries are directed to its named graph
storage. <a href="../tdb/">TDB</a> and <a href="../sdb/">SDB</a> are examples of this.</p>
<h2 id="mixed-graph-implementation-datasets">Mixed Graph Implementation Datasets</h2>
<p>The dataset implementation used in normal operation does not work
on quads but instead can provide a dataset with a collection of
graphs each from different implementation sub-systems. In-memory
graphs can be mixed with database backed graphs as well as custom
storage systems. Query execution proceeds per-graph so that an
custom <code>OpExecutor</code> will need to test the graph to work with to
make sure it is of the right class. The pattern in the
<code>StageGenerator</code> extension point is an example of design pattern in
that situation.</p>
<h2 id="custom-query-engines">Custom Query Engines</h2>
<p>A custom query engine enables an extension to choose which datasets
it wishes to handle. It also allows the extension to intercept
query execution during the setup of the execution so it can modify
the algebra expression, introduce it's own algebra extensions,
choose which high-level optimizations to apply and also transform
to the expression into quad form. Execution can proceed with the
normal algorithm or a custom <code>OpExecutor</code> or a custom Stage
Generator or a combination of all three extension mechanism.</p>
<p>Only a small, skeleton custom query engine is needed to intercept
the initial setup. See the example in
<code>src-examples/arq.examples.engine.MyQueryEngine</code>.</p>
<p>While it is possible to replace the entire process of query
evaluation, this is a substantial endeavour. <code>QueryExecutionBase</code>
provides the machinery for result presentation (<code>SELECT</code>,
<code>CONSTRUCT</code>, <code>DESCRIBE</code>, <code>ASK</code>), leaving the work of pattern
evaluation to the custom query engine. <code>QueryExecutionFactory</code>
assumes that <code>QueryExecutionBase</code> will be used.</p>
<h2 id="algebra-extensions">Algebra Extensions</h2>
<p>New operators can be added to the algebra using the <code>OpExt</code> class
as the super-class of the new operator. They can be inserted into
the expression to be evaluated using a custom query engine to
intercept evaluation initialization.  When evaluation of a query
requires the evaluation of a sub-class of <code>OpExt</code>, the <code>eval</code>
method is called. SDB uses this to introduce an operator that is
implemented in SQL.</p>
  </div>

  <div id="footer">
    <div class="copyright">
      <p>
        Copyright &copy; 2011&ndash;2013 The Apache Software Foundation, Licensed under
        the <a href="http://www.apache.org/licenses/LICENSE-2.0">Apache License, Version 2.0</a>.
        <br />
        Apache Jena, Jena, the Apache Jena project logo,
        Apache and the Apache feather logos are trademarks of The Apache Software Foundation.
      </p>
    </div>
  </div>

</body>
</html>
