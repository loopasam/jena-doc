<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<!--

    Licensed to the Apache Software Foundation (ASF) under one or more
    contributor license agreements.  See the NOTICE file distributed with
    this work for additional information regarding copyright ownership.
    The ASF licenses this file to You under the Apache License, Version 2.0
    (the "License"); you may not use this file except in compliance with
    the License.  You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE- 2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
-->

  <link href="/css/jena.css" rel="stylesheet" type="text/css">

  <title>Apache Jena - </title>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js" type="text/javascript"></script>
  <script src="/js/jena-navigation.js" type="text/javascript"></script>
</head>

<body>
  <div id="header">
    <div id="logoblock">
    <img alt="Apache Jena" src="/images/jena-logo/jena-logo-small.png"/>
    </div>

    <div id="titleblock">
      <h1 class="title">Apache Jena</h1>
      <div id="topmenu" class="tabbar round-10">
        <ul>
        <li class="round-top-8"><a class="round-top-8" href="/index.html" id="home_menu">Home</a></li>
        <li class="round-top-8"><a class="round-top-8" href="/help_and_support/index.html">Support</a></li>
        <li class="round-top-8"><a class="round-top-8" href="/getting_started/index.html">Getting started</a></li>
        <li class="round-top-8"><a class="round-top-8" href="/tutorials/index.html">Tutorials</a></li>
        <li class="round-top-8"><a class="round-top-8" href="/documentation/index.html">Documentation</a></li>
        </ul>
      </div>
    </div>
  </div>

  <div id="navigation" class="clear">
  <h1 id="quick-links">Quick links</h1>
<ul>
<li><a href="/index.html">Home</a></li>
<li><a href="/download/index.html">Downloads</a></li>
<li><a href="/help_and_support/index.html">Help and support</a></li>
<li><a href="/help_and_support/bugs_and_suggestions.html">Report a bug</a></li>
<li><a href="/about_jena/roadmap.html">Roadmap</a></li>
<li><a href="/getting_involved/index.html">Getting involved</a></li>
<li><a href="/documentation/">Documentation</a></li>
</ul>
<h1 id="about-jena">About Jena</h1>
<ul>
<li><a href="/index.html">Home</a></li>
<li><a href="/about_jena/about.html">About Jena</a></li>
<li><a href="/about_jena/architecture.html">Architecture</a></li>
<li><a href="/about_jena/roadmap.html">Roadmap</a></li>
<li><a href="/about_jena/team.html">Project team</a></li>
<li><a href="/about_jena/contributions.html">Related projects</a></li>
</ul>
<h1 id="download">Download</h1>
<ul>
<li><a href="/download/index.html">Downloading Jena</a></li>
<li><a href="/download/maven.html">Using Maven</a></li>
<li><a href="/download/osgi.html">Using OSGi</a></li>
</ul>
<h1 id="help-and-support">Help and support</h1>
<ul>
<li><a href="/help_and_support/index.html">Getting help</a></li>
<li><a href="/help_and_support/bugs_and_suggestions.html">Bugs and suggestions</a></li>
</ul>
<h1 id="getting-started">Getting Started</h1>
<ul>
<li><a href="/getting_started/index.html">A first Jena project</a></li>
<li><a href="/getting_started/rdf_api.html">RDF API overview</a></li>
<li><a href="/getting_started/sparql.html">Querying RDF with SPARQL</a></li>
<li><a href="/getting_started/fuseki.html">Serving RDF over HTTP</a></li>
<li><a href="/getting_started/tell_me_how.html">Tell me how to ...</a></li>
</ul>
<h1 id="tutorials">Tutorials</h1>
<ul>
<li><a href="/tutorials/index.html">Tutorials index</a></li>
<li><a href="/tutorials/rdf_api.html">RDF tutorial</a></li>
<li><a href="/tutorials/sparql.html">SPARQL queries</a></li>
<li><a href="/tutorials/using_jena_with_eclipse.html">Using Jena with Eclipse</a></li>
</ul>
<h1 id="documentation">Documentation</h1>
<ul>
<li><a href="/documentation/index.html">Overview</a></li>
<li><a href="/documentation/javadoc/">Javadoc</a></li>
<li><a href="/documentation/rdf/index.html">RDF</a></li>
<li><a href="/documentation/io/index.html">I/O</a></li>
<li><a href="/documentation/query/index.html">SPARQL (ARQ)</a><ul>
<li><a href="/documentation/query/app_api.html">Application API</a></li>
<li><a href="/documentation/query/cmds.html">Command line utilities</a></li>
</ul>
</li>
<li><a href="/documentation/query/text-query.html">Text Search</a></li>
<li><a href="/documentation/tdb/index.html">TDB</a><ul>
<li><a href="/documentation/tdb/tdb_transactions.html">API for Transactions</a></li>
<li><a href="/documentation/tdb/assembler.html">Dataset Assembler</a></li>
</ul>
</li>
<li><a href="/documentation/serving_data/index.html">Fuseki: Serving Data</a></li>
<li><a href="/documentation/ontology/index.html">Ontology</a></li>
<li><a href="/documentation/inference/index.html">Inference</a></li>
<li><a href="/documentation/assembler/index.html">Assembler</a><ul>
<li><a href="/documentation/assembler/assembler-howto.html">Assembler how-to</a></li>
<li><a href="/documentation/assembler/inside-assemblers.html">Inside assemblers</a></li>
</ul>
</li>
<li><a href="/documentation/sdb/index.html">SDB</a></li>
<li><a href="/documentation/notes/index.html">Notes</a><ul>
<li><a href="/documentation/notes/concurrency-howto.html">Concurrency how-to</a></li>
<li><a href="/documentation/notes/event-handler-howto.html">Event handler how-to</a></li>
<li><a href="/documentation/notes/file-manager.html">File manager how-to</a></li>
<li><a href="/documentation/notes/model-factory.html">Model factory how-to</a></li>
<li><a href="/documentation/notes/rdf-frames.html">RDF frames</a></li>
<li><a href="/documentation/notes/reification.html">Reification how-to</a></li>
<li><a href="/documentation/notes/typed-literals.html">Typed literals how-to</a></li>
<li><a href="/documentation/notes/iri.html">Support for IRI's</a></li>
<li><a href="/documentation/notes/sse.html">SSE</a></li>
</ul>
</li>
<li><a href="/documentation/tools/index.html">Tools</a><ul>
<li><a href="/documentation/tools/schemagen.html">schemagen</a></li>
<li><a href="/documentation/tools/eyeball-getting-started.html">eyeball</a></li>
</ul>
</li>
</ul>
<h1 id="getting-involved">Getting Involved</h1>
<ul>
<li><a href="/getting_involved/index.html">Contributing to Jena</a><ul>
<li><a href="/getting_involved/reviewing_contributions.html">Reviewing Contributions</a></li>
</ul>
</li>
</ul>
<h1 id="asf-links">ASF links</h1>
<ul>
<li><a href="http://www.apache.org">Apache Software Foundation</a></li>
<li><a href="http://www.apache.org/licenses/LICENSE-2.0">License</a></li>
<li><a href="http://www.apache.org/foundation/thanks.html">Thanks</a></li>
<li><a href="http://www.apache.org/foundation/sponsorship.html">Become a Sponsor</a></li>
<li><a href="http://www.apache.org/security/">Security</a></li>
</ul>
  </div>

  <div id="content">
    <h1 class="title"></h1>
    <h1 id="arq-property-paths">ARQ - Property Paths</h1>
<p>A property path is a possible route through a graph between two
graph nodes.  A trivial case is a property path of length exactly
one, which is a triple pattern.</p>
<p>Most property paths are now legal SPARQL 1.1 syntax, there are some advanced property 
paths which are syntactic extensions and are only available if the query is parsed with language <code>Syntax.syntaxARQ</code>.</p>
<h2 id="path-language">Path Language</h2>
<p>A property path expression (or just 'path') is similar to a string
regular expression but over properties, not characters. ARQ
determines all matches of a path expression and binds subject or
object as appropriate. Only one match is recorded - no duplicates
for any given path expression, although is the path is used in a
situation where it's initial points is already repeated in a
pattern, then this duplication is preserved.</p>
<table>
<thead>
<tr>
<th>Path example</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td><tt>dc:title &#x7C; rdfs:label</tt></td>
<td>Dublin Core title or an RDFS label.</td>
</tr>
<tr>
<td><code>foaf:knows/foaf:name</code></td>
<td>Name of people one "knows" steps away.</td>
</tr>
<tr>
<td><code>foaf:knows/foaf:knows/foaf:name</code></td>
<td>Name of people two "knows" steps away.</td>
</tr>
</tbody>
</table>
<p>In the description below, <em><code>uri</code></em> is either a URI or a prefixed
name.</p>
<table>
<thead>
<tr>
<th>Syntax Form</th>
<th>Matches</th>
</tr>
</thead>
<tbody>
<tr>
<td><tt><i>uri</i></tt></td>
<td>A URI or a prefixed name. A path of length one.</td>
</tr>
<tr>
<td><tt>^<i>elt</i></tt></td>
<td>Reverse path (object to subject)</td>
</tr>
<tr>
<td><tt>(<i>elt</i>)</tt></td>
<td>A group path <em><code>elt</code></em>, brackets control precedence.</td>
</tr>
<tr>
<td><tt><i>elt1</i> / <i>elt2</i></tt></td>
<td>A sequence path of <em><code>elt1</code></em>, followed by <em><code>elt2</code></em></td>
</tr>
<tr>
<td><tt><i>elt1</i> &#x7C; <i>elt2</i></tt></td>
<td>A alternative path of <tt><i>elt1</i></tt>, or <tt><i>elt2</i></tt> (both possibilities are tried)</td>
</tr>
<tr>
<td><tt><i>elt</i>*</tt></td>
<td>A path of zero or more occurrences of <em><code>elt</code></em>.</td>
</tr>
<tr>
<td><tt><i>elt</i>+</tt></td>
<td>A path of one or more occurrences of <em><code>elt</code></em>.</td>
</tr>
<tr>
<td><tt><i>elt</i>?</tt></td>
<td>A path of zero or one <em><code>elt</code></em>.</td>
</tr>
<tr>
<td><tt>!<i>uri</i></tt></td>
<td>A path matching a property which isn't <tt><i>uri</i></tt> (negated property set)</td>
</tr>
<tr>
<td><tt>!(<i>uri1</i>&#x7C;...&#x7C;<i>uriN</i>)</tt></td>
<td>A path matching a property which isn't any of <code>uri1 ... uri</code> (negated property set)</td>
</tr>
</tbody>
</table>
<p>ARQ extensions: to use these you must use <code>Syntax.syntaxARQ</code></p>
<table>
<thead>
<tr>
<th>Syntax Form</th>
<th>Matches</th>
</tr>
</thead>
<tbody>
<tr>
<td><tt><i>elt1</i> ^ <i>elt2</i></tt></td>
<td>Shorthand for <tt><i>elt1 / ^elt2</i></tt>, that is <em><code>elt1</code></em> followed by reverse <em><code>elt2</code></em>.</td>
</tr>
<tr>
<td><i><tt>elt</tt></i><code>{n,m}</code></td>
<td>A path between n and m occurrences of <em><code>elt</code></em>.</td>
</tr>
<tr>
<td><i><tt>elt</tt></i><code>{n}</code></td>
<td>Exactly <code>n</code> occurrences of <code>elt</code>. A fixed length path.</td>
</tr>
<tr>
<td><i><tt>elt</tt></i><code>{n,}</code></td>
<td><code>n</code> or more occurrences of <em><code>elt</code></em>.</td>
</tr>
<tr>
<td><i><tt>elt</tt></i><code>{,n}</code></td>
<td>Between 0 and <code>n</code> occurrences of <em><code>elt</code></em>.</td>
</tr>
</tbody>
</table>
<p>Precedence:</p>
<ol>
<li>URI, prefixed names</li>
<li>Negated property set</li>
<li>Groups</li>
<li>Unary \^ reverse links</li>
<li>Unary operators <code>*</code>, <code>?</code>, <code>+</code> and <code>{}</code> forms</li>
<li>Binary operators <code>/</code> and \^</li>
<li>Binary operator <code>|</code></li>
</ol>
<p>Precedence is left-to-right within groups.</p>
<h2 id="path-evaluation">Path Evaluation</h2>
<p>Paths are "simple" if they involve only operators / (sequence), \^
(reverse, unary or binary) and the form {<em>n</em>}, for some single
integer <em>n</em>. Such paths are fixed length. They are translated to
triple patterns by the query compiler and do not require special
path-evaluation at runtime.</p>
<p>A path of just a URI is still a single triple pattern.</p>
<p>A path is "complex"  if it involves one or more of the operators
*,?, + and {}. Such paths require special evaluation and provide
expressivity outside of strict SPARQL because paths can be of
variable length. When used with models backed by SQL databases,
complex path expressions may take some time.</p>
<p>A path of length zero connects a graph node to itself.</p>
<p>Cycles in paths are possible and are handled.</p>
<p>Paths do not need to be anchored at one end of the other, although
this can lead to large numbers of result because the whole graph is
searched.</p>
<p>Property functions in paths are only available for simple paths.</p>
<h2 id="extended-language">Extended Language</h2>
<p>This involves is syntactic extension and is available if the query
is parsed with language <code>Syntax.syntaxARQ</code>.</p>
<p>Paths can be directly included in the query in the property
position of a triple pattern:</p>
<div class="codehilite"><pre><span class="n">PREFIX</span> <span class="o">:</span>     <span class="o">&lt;</span><span class="n">http</span><span class="o">:</span><span class="c1">//example/&gt;</span>
<span class="n">PREFIX</span> <span class="n">rdf</span><span class="o">:</span>  <span class="o">&lt;</span><span class="n">http</span><span class="o">:</span><span class="c1">//www.w3.org/1999/02/22-rdf-syntax-ns#&gt;</span>
<span class="n">PREFIX</span> <span class="n">rdfs</span><span class="o">:</span> <span class="o">&lt;</span><span class="n">http</span><span class="o">:</span><span class="c1">//www.w3.org/2000/01/rdf-schema#&gt;</span>

<span class="cp"># Find the types of :x, following subClassOf</span>
<span class="n">SELECT</span> <span class="o">*</span>
<span class="p">{</span>
   <span class="o">:</span><span class="n">x</span>  <span class="n">rdf</span><span class="o">:</span><span class="n">type</span><span class="o">/</span><span class="n">rdfs</span><span class="o">:</span><span class="n">subClassOf</span><span class="o">*</span>  <span class="o">?</span><span class="n">t</span>
<span class="p">}</span>
</pre></div>


<h2 id="examples">Examples</h2>
<h3 id="simple-paths">Simple Paths</h3>
<p>Find the name of any people that Alice knows.</p>
<div class="codehilite"><pre><span class="p">{</span>
  <span class="o">?</span><span class="n">x</span> <span class="n">foaf</span><span class="o">:</span><span class="n">mbox</span> <span class="o">&lt;</span><span class="n">mailto</span><span class="o">:</span><span class="n">alice</span><span class="err">@</span><span class="n">example</span><span class="o">&gt;</span> <span class="p">.</span>
  <span class="o">?</span><span class="n">x</span> <span class="n">foaf</span><span class="o">:</span><span class="n">knows</span><span class="o">/</span><span class="n">foaf</span><span class="o">:</span><span class="n">name</span> <span class="o">?</span><span class="n">name</span> <span class="p">.</span>
<span class="p">}</span>
</pre></div>


<p>Find the names of people 2 "<code>foaf:knows</code>" links away.</p>
<div class="codehilite"><pre><span class="p">{</span>
  <span class="o">?</span><span class="n">x</span> <span class="n">foaf</span><span class="o">:</span><span class="n">mbox</span> <span class="o">&lt;</span><span class="n">mailto</span><span class="o">:</span><span class="n">alice</span><span class="err">@</span><span class="n">example</span><span class="o">&gt;</span> <span class="p">.</span>
  <span class="o">?</span><span class="n">x</span> <span class="n">foaf</span><span class="o">:</span><span class="n">knows</span><span class="o">/</span><span class="n">foaf</span><span class="o">:</span><span class="n">knows</span><span class="o">/</span><span class="n">foaf</span><span class="o">:</span><span class="n">name</span> <span class="o">?</span><span class="n">name</span> <span class="p">.</span>
<span class="p">}</span>
</pre></div>


<p>This is the same as the strict SPARQL query:</p>
<div class="codehilite"><pre><span class="p">{</span>
  <span class="o">?</span><span class="n">x</span>  <span class="n">foaf</span><span class="o">:</span><span class="n">mbox</span> <span class="o">&lt;</span><span class="n">mailto</span><span class="o">:</span><span class="n">alice</span><span class="err">@</span><span class="n">example</span><span class="o">&gt;</span> <span class="p">.</span>
  <span class="o">?</span><span class="n">x</span>  <span class="n">foaf</span><span class="o">:</span><span class="n">knows</span> <span class="p">[</span> <span class="n">foaf</span><span class="o">:</span><span class="n">knows</span> <span class="p">[</span> <span class="n">foaf</span><span class="o">:</span><span class="n">name</span> <span class="o">?</span><span class="n">name</span> <span class="p">]].</span>
<span class="p">}</span>
</pre></div>


<p>or, with explicit variables:</p>
<div class="codehilite"><pre><span class="p">{</span>
  <span class="o">?</span><span class="n">x</span>  <span class="n">foaf</span><span class="o">:</span><span class="n">mbox</span> <span class="o">&lt;</span><span class="n">mailto</span><span class="o">:</span><span class="n">alice</span><span class="err">@</span><span class="n">example</span><span class="o">&gt;</span> <span class="p">.</span>
  <span class="o">?</span><span class="n">x</span>  <span class="n">foaf</span><span class="o">:</span><span class="n">knows</span> <span class="o">?</span><span class="n">a1</span> <span class="p">.</span>
  <span class="o">?</span><span class="n">a1</span> <span class="n">foaf</span><span class="o">:</span><span class="n">knows</span> <span class="o">?</span><span class="n">a2</span> <span class="p">.</span>
  <span class="o">?</span><span class="n">a2</span> <span class="n">foaf</span><span class="o">:</span><span class="n">name</span> <span class="o">?</span><span class="n">name</span> <span class="p">.</span>
<span class="p">}</span>
</pre></div>


<p>Because someone Alice knows may well know Alice, the example above
may include Alice herself. This could be avoided with:</p>
<div class="codehilite"><pre><span class="p">{</span> <span class="o">?</span><span class="n">x</span> <span class="n">foaf</span><span class="o">:</span><span class="n">mbox</span> <span class="o">&lt;</span><span class="n">mailto</span><span class="o">:</span><span class="n">alice</span><span class="err">@</span><span class="n">example</span><span class="o">&gt;</span> <span class="p">.</span>
  <span class="o">?</span><span class="n">x</span> <span class="n">foaf</span><span class="o">:</span><span class="n">knows</span><span class="o">/</span><span class="n">foaf</span><span class="o">:</span><span class="n">knows</span> <span class="o">?</span><span class="n">y</span> <span class="p">.</span>
  <span class="n">FILTER</span> <span class="p">(</span> <span class="o">?</span><span class="n">x</span> <span class="o">!=</span> <span class="o">?</span><span class="n">y</span> <span class="p">)</span>
  <span class="o">?</span><span class="n">y</span> <span class="n">foaf</span><span class="o">:</span><span class="n">name</span> <span class="o">?</span><span class="n">name</span>
<span class="p">}</span>
</pre></div>


<p>These two are the same query: the second is just reversing the
property direction which swaps the roles of subject and object.</p>
<div class="codehilite"><pre><span class="p">{</span> <span class="o">?</span><span class="n">x</span> <span class="n">foaf</span><span class="o">:</span><span class="n">mbox</span> <span class="o">&lt;</span><span class="n">mailto</span><span class="o">:</span><span class="n">alice</span><span class="err">@</span><span class="n">example</span><span class="o">&gt;</span> <span class="p">}</span>

<span class="p">{</span> <span class="o">&lt;</span><span class="n">mailto</span><span class="o">:</span><span class="n">alice</span><span class="err">@</span><span class="n">example</span><span class="o">&gt;</span> <span class="o">^</span><span class="n">foaf</span><span class="o">:</span><span class="n">mbox</span> <span class="o">?</span><span class="n">x</span> <span class="p">}</span>
</pre></div>


<p>Mutual <code>foaf:knows</code> relationships: <code>?x</code> knows someone who knows
<code>?x</code></p>
<div class="codehilite"><pre><span class="p">{</span>
  <span class="o">?</span><span class="n">x</span> <span class="n">foaf</span><span class="o">:</span><span class="n">knows</span><span class="o">^</span><span class="n">foaf</span><span class="o">:</span><span class="n">knows</span> <span class="o">?</span><span class="n">x</span> <span class="p">.</span>
<span class="p">}</span>
</pre></div>


<p>Negated property sets define matching by naming one or more
properties that must not match. Match if there is a triple from
<code>?x</code> to <code>?y</code> which is not <code>rdf:type</code>.</p>
<div class="codehilite"><pre><span class="p">{</span>
  <span class="o">?</span><span class="n">x</span> <span class="o">!</span><span class="n">rdf</span><span class="o">:</span><span class="n">type</span> <span class="o">?</span><span class="n">y</span> <span class="p">.</span>
<span class="p">}</span>

<span class="p">{</span>
  <span class="o">?</span><span class="n">x</span> <span class="o">!</span><span class="p">(</span><span class="n">rdf</span><span class="o">:</span><span class="n">type</span><span class="o">|^</span><span class="n">rdf</span><span class="o">:</span><span class="n">type</span><span class="p">)</span> <span class="o">?</span><span class="n">y</span> <span class="p">.</span>
<span class="p">}</span>
</pre></div>


<p>Only properties and reverse properties are allowed in a negated
property set, not a full path expression.</p>
<h3 id="complex-paths">Complex Paths</h3>
<p>Find the names of all the people can be reached from Alice by
<code>foaf:knows</code>:</p>
<div class="codehilite"><pre><span class="p">{</span>
  <span class="o">?</span><span class="n">x</span> <span class="n">foaf</span><span class="o">:</span><span class="n">mbox</span> <span class="o">&lt;</span><span class="n">mailto</span><span class="o">:</span><span class="n">alice</span><span class="err">@</span><span class="n">example</span><span class="o">&gt;</span> <span class="p">.</span>
  <span class="o">?</span><span class="n">x</span> <span class="n">foaf</span><span class="o">:</span><span class="n">knows</span><span class="o">+/</span><span class="n">foaf</span><span class="o">:</span><span class="n">name</span> <span class="o">?</span><span class="n">name</span> <span class="p">.</span>
<span class="p">}</span>
</pre></div>


<p>Again, because of cycles in <code>foaf:knows</code> relationships, it is
likely to include Alice herself.</p>
<p>Some forms of limited inference are possible as well. For example:
all types and supertypes of a resource:</p>
<div class="codehilite"><pre><span class="p">{</span> <span class="o">&lt;</span><span class="n">http</span><span class="o">:</span><span class="c1">//example/&gt; rdf:type/rdfs:subClassOf* ?type }</span>
</pre></div>


<p>All resources and all their inferred types:</p>
<div class="codehilite"><pre><span class="p">{</span> <span class="o">?</span><span class="n">x</span> <span class="n">rdf</span><span class="o">:</span><span class="n">type</span><span class="o">/</span><span class="n">rdfs</span><span class="o">:</span><span class="n">subClassOf</span><span class="o">*</span> <span class="o">?</span><span class="n">type</span> <span class="p">}</span>
</pre></div>


<h2 id="use-with-legal-sparql-syntax">Use with Legal SPARQL Syntax</h2>
<p>A path can parsed, then installed as a
<a href="extension.html#propertyFunctions">property function</a> to be
referred to by URI. This way, when the URI is used in the predicate
location in a triple pattern, the path expression is evaluated.</p>
<div class="codehilite"><pre><span class="n">Path</span> <span class="n">path</span> <span class="o">=</span> <span class="p">...</span>
<span class="n">String</span> <span class="n">uri</span> <span class="o">=</span> <span class="p">...</span>
<span class="n">PathLib</span><span class="p">.</span><span class="n">install</span><span class="p">(</span><span class="n">uri</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span> <span class="p">;</span>
</pre></div>


<p>For example:</p>
<div class="codehilite"><pre><span class="n">Path</span> <span class="n">path</span> <span class="o">=</span> <span class="n">PathParser</span><span class="p">.</span><span class="n">parse</span><span class="p">(</span><span class="s">&quot;rdf:type/rdfs:subClassOf*&quot;</span><span class="p">,</span> <span class="n">PrefixMapping</span><span class="p">.</span><span class="n">Standard</span><span class="p">)</span> <span class="p">;</span>
<span class="n">String</span> <span class="n">uri</span> <span class="o">=</span> <span class="s">&quot;http://example/ns#myType&quot;</span> <span class="p">;</span>
<span class="n">PathLib</span><span class="p">.</span><span class="n">install</span><span class="p">(</span><span class="n">uri</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span> <span class="p">;</span>
</pre></div>


<p>and the SPARQL query:</p>
<div class="codehilite"><pre><span class="n">PREFIX</span> <span class="o">:</span> <span class="o">&lt;</span><span class="n">http</span><span class="o">:</span><span class="c1">//example/&gt;</span>
<span class="n">PREFIX</span> <span class="n">ns</span><span class="o">:</span> <span class="o">&lt;</span><span class="n">http</span><span class="o">:</span><span class="c1">//example/ns#&gt;</span>
<span class="cp"># Find the types of :x, following subClassOf</span>
<span class="n">SELECT</span> <span class="o">*</span> <span class="p">{</span> <span class="o">:</span><span class="n">x</span> <span class="n">ns</span><span class="o">:</span><span class="n">myType</span> <span class="o">?</span><span class="n">t</span><span class="p">}</span>
</pre></div>


<p>This also works with if an existing property is redefined (a URI in
a path expression is not interpreted as a property function) so,
for example, <code>rdf:type</code> can be redefined as a path that also
considers RDFS sub -class relationships. The path is a complex path
so the property function for <code>rdf:type</code> is not triggered.</p>
<div class="codehilite"><pre><span class="n">Path</span> <span class="n">path</span> <span class="o">=</span> <span class="n">PathParser</span><span class="p">.</span><span class="n">parse</span><span class="p">(</span><span class="s">&quot;rdf:type/rdfs:subClassOf*&quot;</span><span class="p">,</span> <span class="n">PrefixMapping</span><span class="p">.</span><span class="n">Standard</span><span class="p">)</span> <span class="p">;</span>
<span class="n">PathLib</span><span class="p">.</span><span class="n">install</span><span class="p">(</span><span class="n">RDF</span><span class="p">.</span><span class="n">type</span><span class="p">.</span><span class="n">getURI</span><span class="p">(),</span> <span class="n">path</span><span class="p">)</span> <span class="p">;</span>
</pre></div>


<p><a href="index.html">ARQ documentation index</a></p>
  </div>

  <div id="footer">
    <div class="copyright">
      <p>
        Copyright &copy; 2011&ndash;2013 The Apache Software Foundation, Licensed under
        the <a href="http://www.apache.org/licenses/LICENSE-2.0">Apache License, Version 2.0</a>.
        <br />
        Apache Jena, Jena, the Apache Jena project logo,
        Apache and the Apache feather logos are trademarks of The Apache Software Foundation.
      </p>
    </div>
  </div>

</body>
</html>
